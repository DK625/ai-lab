Kiến trúc bạn cung cấp mô tả một hệ thống **Điều phối Đa tác vụ Tự động (Autonomous Multi-Agent Coordination)**. Đây là mô hình "Não bộ và Tay chân", trong đó một thực thể trung tâm (Orchestrator) quản lý nhiều thực thể thực thi (Workers) chạy song song để hoàn thành một dự án lớn.

Dưới đây là giải thích chi tiết về cách vận hành của kiến trúc này:

---

### 1. Đầu vào: Bản thiết kế (Execution Plan)

Trước khi khởi động, Orchestrator cần một "bản đồ" đã được chuẩn bị từ kỹ năng `planning`. Bản đồ này (`execution-plan.md`) chứa:

* **Danh sách Tracks**: Các luồng công việc độc lập (ví dụ: Track 1 cho SDK, Track 2 cho Server).
* **File Scope**: Phân vùng cụ thể để các Agent không sửa đè file của nhau.
* **Dependencies**: Các điểm mà một luồng phải đợi luồng khác mới được chạy tiếp.

### 2. Bộ não trung tâm: Orchestrator

Orchestrator không trực tiếp viết code. Vai trò của nó là **Quản trị và Giám sát**:

* **Khởi tạo (Spawn)**: Sử dụng công cụ `Task()` để tạo ra các sub-agents (Workers) cùng một lúc.
* **Theo dõi (Monitor)**: Nó liên tục kiểm tra "Hộp thư" (Agent Mail) để xem ai đã xong việc, ai đang gặp lỗi.
* **Giải quyết xung đột**: Nếu hai Agent tranh chấp file hoặc một Agent bị "block", Orchestrator sẽ can thiệp để điều phối lại.

### 3. Đội ngũ thực thi: Worker Subagents

Đây là các Agent chuyên biệt (được đặt tên như BlueLake, GreenCastle) thực hiện công việc thực tế. Mỗi Worker hoạt động theo chu kỳ:

1. **Nhận Bead**: Lấy một nhiệm vụ cụ thể từ danh sách.
2. **Giữ File (Reserve)**: Đảm bảo mình đang làm việc trong đúng phạm vi `file_scope` được giao.
3. **Thực thi**: Viết code, chạy test, hoàn thành nhiệm vụ.
4. **Báo cáo (Report mail)**: Gửi cập nhật trạng thái về cho Orchestrator thông qua hệ thống Mail.

### 4. Hệ thống liên lạc: Agent Mail
#### 1. Epic Thread: Luồng Điều Phối Tổng Thể

Đây là kênh liên lạc cấp cao nhất, nơi **Orchestrator** đóng vai trò là "người nghe" chính để nắm bắt tình hình toàn cục.

* **Progress reports (Báo cáo tiến độ):** Các cập nhật nhanh về việc các Track đang ở đâu so với kế hoạch.
* **Bead completions (Hoàn thành nhiệm vụ):** Thông báo khi một Bead cụ thể đã xong. Đây là tín hiệu để Orchestrator kiểm tra xem có thể mở khóa (unblock) cho các Track khác đang đợi hay không.
* **Blockers (Vấn đề gây tắc nghẽn):** Các lỗi nghiêm trọng hoặc sự cố làm dừng luồng công việc sẽ được đẩy lên đây. Việc đưa Blocker vào Epic Thread giúp Orchestrator thấy ngay tầm ảnh hưởng của nó đối với các Track khác để đưa ra quyết định điều phối kịp thời.

#### 2. Track Threads: Luồng Thực Thi Chi Tiết

Mỗi Track (như BlueLake, RedStone) sẽ có một luồng riêng. Đây giống như một "nhật ký kỹ thuật" cho từng nhóm Agent.

* **Bead context (Ngữ cảnh nhiệm vụ):** Chứa các hướng dẫn chi tiết, dữ liệu đầu vào và các yêu cầu cụ thể chỉ dành cho các Bead thuộc Track đó.
* **Learnings (Bài học rút ra):** Khi một Agent thực hiện xong một Bead khó, nó sẽ ghi lại các kinh nghiệm kỹ thuật tại đây. Những thông tin này giúp các Agent kế tiếp trong cùng Track có thể kế thừa kiến thức mà không cần hỏi lại Orchestrator.

---

### Tại sao lại chia ra như vậy?

Cấu trúc này giúp giải quyết vấn đề **Nhiễu thông tin (Signal vs. Noise)**:

| Đặc điểm | Epic Thread | Track Threads |
| --- | --- | --- |
| **Đối tượng** | Orchestrator & Tất cả Workers | Chỉ Worker trong Track đó |
| **Mục đích** | Đồng bộ hóa và ra quyết định | Thực hiện công việc chuyên môn |
| **Nội dung** | "Cái gì đã xong?", "Ai đang bị kẹt?" | "Làm cái này như thế nào?", "Cần chú ý gì?" |

### Tóm tắt luồng xử lý Blocker

Dù Blocker nằm trong **Epic Thread**, nhưng cách nó được xử lý rất bài bản:

1. **Worker** phát hiện lỗi không thể tự giải quyết.
2. **Worker** gửi tin nhắn Blocker lên **Epic Thread**.
3. **Orchestrator** nhận tin, phân tích xem lỗi này có ảnh hưởng đến File Scope của Track khác không.
4. **Orchestrator** phản hồi (Reply) trực tiếp vào luồng đó để hướng dẫn Worker xử lý hoặc điều chỉnh lại Execution Plan.